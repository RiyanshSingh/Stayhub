-- Enable UUID extension (optional but good practice, though we stick to integer IDs to match existing frontend logic for now)

-- Users Table
create table public.users (
  id bigint generated by default as identity primary key,
  name text,
  email text unique,
  password text,
  avatar text,
  phone text,
  address text,
  gender text,
  security_question text,
  security_answer text,
  created_at timestamptz default now()
);

-- Properties Table
create table public.properties (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(id) on delete cascade,
  name text,
  slug text unique,
  description text,
  price numeric,
  location text,
  city text,
  country text,
  type text,
  amenities jsonb, -- Changed to JSONB for better querying
  images jsonb,    -- Changed to JSONB
  currency text,
  rating numeric default 0,
  review_count integer default 0, -- standardized to snake_case in DB, will verify mapping in code
  category text,
  created_at timestamptz default now()
);

-- Bookings Table
create table public.bookings (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(id) on delete set null,
  property_id bigint references public.properties(id) on delete set null,
  property_name text,
  property_image text,
  check_in text, -- Keeping as text to match existing format (likely ISO string or YYYY-MM-DD)
  check_out text,
  guests integer,
  total_price numeric,
  nights integer,
  status text default 'confirmed',
  cancellation_reason text,
  refund_status text,
  payment_method text,
  transaction_id text,
  created_at timestamptz default now()
);

-- Reviews Table
create table public.reviews (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(id) on delete cascade,
  property_id bigint references public.properties(id) on delete cascade,
  booking_id bigint references public.bookings(id) on delete cascade,
  rating numeric,
  comment text,
  created_at timestamptz default now()
);

-- Support Tickets Table
create table public.support_tickets (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(id) on delete cascade,
  booking_id bigint references public.bookings(id) on delete set null,
  subject text,
  status text default 'Open',
  created_at timestamptz default now()
);

-- Messages Table
create table public.messages (
  id bigint generated by default as identity primary key,
  ticket_id bigint references public.support_tickets(id) on delete cascade,
  sender text,
  text text,
  created_at timestamptz default now()
);

-- Wishlist Table
create table public.wishlist (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(id) on delete cascade,
  property_id bigint references public.properties(id) on delete cascade,
  created_at timestamptz default now(),
  unique(user_id, property_id)
);

-- Notifications Table
create table public.notifications (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(id) on delete cascade,
  type text,
  message text,
  is_read integer default 0, -- 0 or 1
  link text,
  created_at timestamptz default now()
);

-- Row Level Security (RLS)
-- For a simple backend-as-service where the Node server uses the Service Role Key, 
-- we can leave RLS disabled or enable it but bypass it with our key.
-- However, if we enable RLS, we must create policies. 
-- For now, simplest path for migration is to rely on server-side auth logic.
alter table public.users enable row level security;
alter table public.properties enable row level security;
alter table public.bookings enable row level security;
alter table public.reviews enable row level security;
alter table public.support_tickets enable row level security;
alter table public.messages enable row level security;
alter table public.wishlist enable row level security;
alter table public.notifications enable row level security;

-- Create policies that allow the service role (which the backend uses) to do everything.
-- AND potentially allow public access if you were connecting from frontend directly (which we aren't).
-- Since we are connecting via a backend using the SERVICE_KEY or with RLS ignored, 
-- we technically don't need policies if we use the service key. 
-- BUT, if using the ANON key, everything will be blocked.
-- Let's create a permissive policy for now to avoid "permisison denied" errors if user uses Anon key by mistake.
-- WARNING: This allows public access if Anon key is used. Secure by using proper key on backend.

create policy "Enable access to all users" on public.users for all using (true) with check (true);
create policy "Enable access to all properties" on public.properties for all using (true) with check (true);
create policy "Enable access to all bookings" on public.bookings for all using (true) with check (true);
create policy "Enable access to all reviews" on public.reviews for all using (true) with check (true);
create policy "Enable access to all support_tickets" on public.support_tickets for all using (true) with check (true);
create policy "Enable access to all messages" on public.messages for all using (true) with check (true);
create policy "Enable access to all wishlist" on public.wishlist for all using (true) with check (true);
create policy "Enable access to all notifications" on public.notifications for all using (true) with check (true);
